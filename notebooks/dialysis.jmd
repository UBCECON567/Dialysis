---
title       : "Assignment: reproducing Grieco & McDevitt (2017)"
subtitle    : 
author      : Paul Schrimpf
date        : `j using Dates; print(Dates.today())`
bibliography: "../../../565.bib"

---

<a rel="license"
href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative
Commons License" style="border-width:0"
src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"
/></a><br />This work is licensed under a <a rel="license"
href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
Commons Attribution-ShareAlike 4.0 International License</a>.

### About this document {-}

This document was created using Weave.jl. The code is available in
[on github](https://github.com/ECON567/GriecoMcDevitt). The same
document generates both static webpages and associated jupyter
notebooks.

$$
\def\indep{\perp\!\!\!\perp}
\def\Er{\mathrm{E}}
\def\R{\mathbb{R}}
\def\En{{\mathbb{E}_n}}
\def\Pr{\mathrm{P}}
\newcommand{\norm}[1]{\left\Vert {#1} \right\Vert}
\newcommand{\abs}[1]{\left\vert {#1} \right\vert}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\def\inprob{\,{\buildrel p \over \rightarrow}\,} 
\def\indist{\,{\buildrel d \over \rightarrow}\,} 
$$

# Getting started 

[https://vse.syzygy.ca](https://vse.syzygy.ca) provides a convenient
browser based interface to Julia. Open it and log in. This assignment
is in a git repository at
[https://github.com/UBCECON567/Dialysis](https://github.com/UBCECON567/Dialysis). Start
by cloning the git repository to your syzygy directory. Open a
terminal in syzygy (File -> New -> Terminal). This will open a Linux
shell in your browser. To clone the git repository, enter 

`
git clone https://github.com/UBCECON567/Dialysis
`

This will create a directory called `Dialysis` containing all the
files related to this assignment. 

Clicking on the folder icon near the top left of the screen opens a
file browser panel. Use it to open the `Dialysis/notebooks`
folder. You can complete this assignment by modifying the
`dialysis.ipynb` notebook. I recommend creating a copy of this
notebook, and then working on the copy. You can create a copy by right
clicking in the file browser panel. Now open your copy of the
notebook.

Notebooks consist of a series of "cells" of either text written in
markdown or Julia code. If you double click on any of the text cells,
you can see the markdown that created it. To go pack to the formatted
text, execute the cell by either clicking the play icon on the top of
the page or typing ctrl and enter together. 

## Loading packages

Like many programming environments (R, Python, etc), Julia relies on
packages for lots of its functionality.The following code will
download and install all the packages required for this
assignment (but the packages will still need to be loaded with `using
...`). Execute this cell. It will take some time. While the cell 
is running, there will be a `[*]` to the left of it. This will change
to `[1]` (or some other number) after the cell is finished
running. The number indicates the order in which the cell was
executed. You can execute cells out of order. This can be useful
during development, but you should always make sure that your notebook
works correctly when cells are executed in order before considering it
complete (that is, make sure the "Run -> Restart Kernel and Run all
Cells" menu option produces the output you want). 

```julia
using Pkg # loads the Pkg package 
Pkg.activate("..") # loads environment specified in "../Project.toml"
                   # This contains a list of packages and their
                   # versions
Pkg.instantiate()  # installs all packages in the environment
```

Some useful functions for this assignment are in
`../src/Dialysis.jl`. We load those functions now. 
```julia
using Revise
if (!("../src" ∈ LOAD_PATH))
  push!(LOAD_PATH, "../src") # so that `using` knows where to find Dialysis.jl
end
using Dialysis
```
The functions in Dialysis.jl are organized into a module, 
just like any other Julia package. Revise.jl is a package to make it
easier to develop packages (like Dialysis.jl). In particular, `using
Revise` will make it so that as soon as you save any modifications to
Dialysis.jl, those modifications will be loaded into your Julia
session without you doing anything extra. 


## Julia basics

Hmmm...

<!-- -------------------------------------------------------------------------------- -->

# Loading and exploring the data

```julia
using DataFrames, Statistics
dialysis = loaddata()
```

ADD LIST OF VARIABLES, SOME SUMMARY STATISTICS


## Create some variables
```julia
sort!(dialysis, (:provfs, :year))
dialysis[:invest] = panellag(:stations, dialysis, :provfs, :year, -1) -
    dialysis[:stations]
dialysis[:labor] = (dialysis[:nurseFT] + 0.5*dialysis[:nursePT]+
                      dialysis[:ptcareFT] + 0.5*dialysis[:ptcarePT])
dialysis[:hiring] = panellag(:labor, dialysis, :provfs, :year, -1) -
    dialysis[:labor]
dialysis[:for_profit] = dialysis[:profit_status].=="For Profit"
dialysis[:inspected_this_year] =
  ((dialysis[:days_since_inspection].>=0) .&
   (dialysis[:days_since_inspection].<365))
stateRates = by(dialysis, :state, df ->
                mean(skipmissing(df[:inspected_this_year])))
rename!(stateRates, :x1 => :state_inspection_rate)
dialysis = join(dialysis, stateRates, on = :state)
dialysis[:fresenius] = dialysis[:chain_name].=="FRESENIUS"
dialysis[:davita] = dialysis[:chain_name].=="DAVITA"
dialysis[:city] = map(uppercase, dialysis[:city])
dialysis[:patient_years] = dialysis[:patient_months]./12

comps = by(dialysis,[:city,:year],
           df -> mapreduce((x) -> ifelse(ismissing(x),0,1*(x>0)), +, df[:patient_months])
           )
rename!(comps, :x1 => :competitors)
dialysis = join(dialysis, comps, on = [:city,:year])

```


# Quality 

```julia
dialysis[:idcat] = categorical(dialysis[:provfs])
qreg = reg(dialysis, @model(pct_septic ~ days_since_inspection + patient_age +
                            pct_female + patient_esrd_years + pct_fistula + comorbidities +
                            hemoglobin, vcov=cluster(idcat)), save=true)
dialysis[:quality] = -qreg.augmentdf[:residuals]
mreg = reg(dialysis, @model(std_mortality ~ days_since_inspection + patient_age +
                            pct_female + patient_esrd_years + pct_fistula + comorbidities +
                            hemoglobin, vcov=cluster(idcat)), save=true)
dialysis[:mort_q] = -mreg.augmentdf[:residuals]
```

# Estimation of $\alpha$

```julia
dialysis[:lpy] = log.(dialysis[:patient_months]./12)
dialysis[:logL] = log.(dialysis[:labor])
dialysis[:logK] = log.(dialysis[:stations])
inc1 = ((dialysis[:patient_months] .> 0) .& (dialysis[:labor] .> 0) .&
           (dialysis[:stations] .> 0) .&
           .!ismissing.(dialysis[:quality]) .&
           .!ismissing.(dialysis[:std_mortality]) .&
           (dialysis[:invest].==0) .&
           (dialysis[:hiring].!=0));
inc1[ismissing.(inc1)] .= false;
dialysis[:inc1] = inc1;
inc1 = findall(inc1);
reg(dialysis[inc1,:], @model(lpy ~ quality + logL + logK, vcov=cluster(idcat)))

dialysis[:inclag] = panellag(:inc1, dialysis, :provfs, :year, 1);
dialysis[:inc2] = (dialysis[:inclag] .&
                   (dialysis[:stations].>0) .&
                   (dialysis[:labor].>0) .&
                   (dialysis[:patient_years].>0) .&
                   .!ismissing.(dialysis[:quality]));
dialysis[:inc2][ismissing.(dialysis[:inc2])] .= false;

data = dialysis[findall(dialysis[:inc2]),:];
data[:lsmr] = log.(data[:std_mortality] .+ .01)
df = data[1:2000,:];
@time (α, Φ) = partiallinearIV(:lpy, :quality, :lsmr,
                               [:hiring, :logL, :logK, :state_inspection_rate, :competitors],
                               data;
                               npregress=(xp, xd,yd)->
                               polyreg(xp,xd,yd,degree=1) )

data[:Φ] = Φ
```

# Estimating $\beta$

```julia
(ωfunc, ηfunc) = errors_gm(:lpy, :logK, :logL, :quality, :Φ, :provfs, :year,
                           data, α; degree=1)

(obj, momenti, cue) = objective_gm([:logK, :logL], data, ηfunc)
cue([0.0,0.0])

using Optim
res = optimize(cue, [0.0, 0.0], [1.0, 1.0], [0.4, 0.2], Fminbox(LBFGS()), autodiff=:forward)

using Plots, Distributions
Plots.plotly()
lb = -0.2
ub = 1.0
ntest = 100
βtest = [rand(2).*(ub-lb) .+ lb for i in 1:ntest]
pfunc = (β->cdf(Chisq(2),cue(β)))
pval = pfunc.(βtest)
βtest = vcat(βtest'...)
crit = 0.9
fig=scatter(βtest[:,1],βtest[:,2], group=(pval.<crit), legend=false,
            markersize=4, markerstrokewidth=0.0, seriesalpha=0.5,
            palette=:heat)
ngrid = 20
b1 = lb:(ub-lb)/ngrid:ub
b2 = copy(b1)
fig=contour!(b1,b2,(a,b)->pfunc([a,b]),
             levels = [0.75, 0.9, 0.95, 0.99],
             contour_labels=true, legend=false)
```
